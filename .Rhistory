ggplot2::ggsave(img, plot = p, width = 8, height = 6, dpi = 300)
doc <- doc |>
officer::body_add_img(src = img, width = 6.5, height = 4.8) |>
officer::body_add_par(
"Note:  This visualization explores pay compression in the public and private sectors across selected countries. Compression ratios are calculated based on the ratio of incomes at the 90th to the 10th percentile.",
style = "Normal"
)
# ---- Write file ----
print(doc, target = file)
}
)
#Pay compression section
generate_pay_compression_section <- function(doc, selected_countries) {
# ---- guards ----
selected_countries <- unique(na.omit(as.character(selected_countries)))
selected_countries <- selected_countries[nzchar(selected_countries)]
if (length(selected_countries) == 0L) {
return(officer::body_add_par(doc, "No countries selected for analysis.", style = "Normal"))
}
# needed data
if (!exists("pay_compression_wide") ||
!all(c("country_name","Public_Sector","Private_Sector") %in% names(pay_compression_wide))) {
return(officer::body_add_par(doc, "Pay compression data is missing.", style = "Normal"))
}
# intro
doc <- officer::body_add_par(doc, "Pay Compression in the Private and Public Sector", style = "heading 1")
doc <- officer::body_add_par(
doc,
"This section presents pay compression ratios (90th/10th percentile) for public and private sectors across selected countries.",
style = "Normal"
)
# ---- data ----
df <- pay_compression_wide |>
dplyr::filter(.data$country_name %in% selected_countries) |>
dplyr::mutate(
Public_Sector  = suppressWarnings(as.numeric(.data$Public_Sector)),
Private_Sector = suppressWarnings(as.numeric(.data$Private_Sector)),
country_name   = as.character(.data$country_name)
) |>
dplyr::filter(is.finite(.data$Public_Sector), is.finite(.data$Private_Sector))
if (nrow(df) == 0L) {
return(officer::body_add_par(doc, "No pay compression data available for the selected countries.", style = "Normal"))
}
# ---- summaries ----
first_country <- selected_countries[1]
country_summary <- df |>
dplyr::group_by(.data$country_name) |>
dplyr::summarise(
public_compression  = round(mean(.data$Public_Sector,  na.rm = TRUE), 1),
private_compression = round(mean(.data$Private_Sector, na.rm = TRUE), 1),
.groups = "drop"
)
# helpers
pick_or_na <- function(x, idx) if (length(idx) && all(!is.na(idx))) x[idx] else NA_character_
if (all(is.na(country_summary$public_compression))) {
highest_public <- lowest_public <- NA_character_
} else {
highest_public <- pick_or_na(country_summary$country_name, which.max(country_summary$public_compression))
lowest_public  <- pick_or_na(country_summary$country_name, which.min(country_summary$public_compression))
}
if (all(is.na(country_summary$private_compression))) {
highest_private <- lowest_private <- NA_character_
} else {
highest_private <- pick_or_na(country_summary$country_name, which.max(country_summary$private_compression))
lowest_private  <- pick_or_na(country_summary$country_name, which.min(country_summary$private_compression))
}
fc_row <- dplyr::filter(country_summary, .data$country_name == first_country)
first_public_compression  <- if (nrow(fc_row) > 0L) fc_row$public_compression[1]  else NA_real_
first_private_compression <- if (nrow(fc_row) > 0L) fc_row$private_compression[1] else NA_real_
# >>> NA-SAFE MEMBERSHIP CHECK <<<
in_first <- isTRUE(any(country_summary$country_name == first_country, na.rm = TRUE))
if (nrow(country_summary) >= 1L && in_first) {
rk_pub <- rank(-country_summary$public_compression,  ties.method = "min")[country_summary$country_name == first_country]
rk_prv <- rank(-country_summary$private_compression, ties.method = "min")[country_summary$country_name == first_country]
public_position  <- dplyr::case_when(rk_pub == 1 ~ "the highest",
rk_pub == nrow(country_summary) ~ "the lowest",
TRUE ~ "in the middle range")
private_position <- dplyr::case_when(rk_prv == 1 ~ "the highest",
rk_prv == nrow(country_summary) ~ "the lowest",
TRUE ~ "in the middle range")
} else {
public_position <- private_position <- "unranked"
}
# ---- plot (no color scale) ----
lim_min <- min(c(df$Private_Sector, df$Public_Sector), na.rm = TRUE)
lim_max <- max(c(df$Private_Sector, df$Public_Sector), na.rm = TRUE)
plt <- ggplot2::ggplot(df, ggplot2::aes(x = .data$Private_Sector, y = .data$Public_Sector)) +
ggplot2::geom_point(size = 3) +
ggplot2::geom_text(ggplot2::aes(label = .data$country_name), vjust = -0.6, size = 3) +
ggplot2::geom_abline(slope = 1, intercept = 0, linetype = "dotted") +   # 45° equality
ggplot2::geom_smooth(method = "lm", se = FALSE, linetype = "dashed", linewidth = 0.8) +  # trendline
ggplot2::coord_equal(xlim = c(lim_min, lim_max), ylim = c(lim_min, lim_max), expand = TRUE) +
ggplot2::labs(
title = "Pay Compression: Public vs. Private Sector",
x = "Private Sector Pay Compression (P90/P10)",
y = "Public Sector Pay Compression (P90/P10)"
) +
ggplot2::theme_minimal()
img_path <- tempfile(fileext = ".png")
ok <- TRUE
tryCatch(ggplot2::ggsave(filename = img_path, plot = plt, width = 8, height = 6, dpi = 300),
error = function(e) { ok <<- FALSE })
# ---- write to doc ----
if (isTRUE(ok) && isTRUE(file.exists(img_path))) {
doc <- officer::body_add_img(doc, src = img_path, width = 6, height = 4)
}
doc <- officer::body_add_par(
doc,
paste0(
"For ", first_country, ", the pay compression ratio is ",
first_public_compression, " in the public sector and ",
first_private_compression, " in the private sector. ",
"Among the selected countries, ", highest_public, " has the highest public-sector compression and ",
lowest_public, " the lowest; in the private sector, ", highest_private, " is highest and ",
lowest_private, " lowest. ",
first_country, " ranks ", public_position, " in public-sector compression and ",
private_position, " in private-sector compression. A higher ratio implies greater inequality within a sector."
),
style = "Normal"
)
doc <- officer::body_add_par(
doc,
"Note: Dashed line is linear fit; dotted line is equality (Public = Private).",
style = "Normal"
)
return(doc)
}
generate_pay_compression_slide <- function(ppt, selected_countries) {
# sanitize countries
selected_countries <- unique(na.omit(as.character(selected_countries)))
selected_countries <- selected_countries[nzchar(selected_countries)]
if (length(selected_countries) == 0L) return(ppt)
# guard data frame
if (!exists("pay_compression_wide") ||
!all(c("country_name","Public_Sector","Private_Sector") %in% names(pay_compression_wide))) {
return(ppt)
}
# filter + coerce numeric + drop non-finite rows
df <- pay_compression_wide %>%
dplyr::filter(.data$country_name %in% selected_countries) %>%
dplyr::mutate(
Public_Sector  = suppressWarnings(as.numeric(.data$Public_Sector)),
Private_Sector = suppressWarnings(as.numeric(.data$Private_Sector)),
country_name   = as.character(.data$country_name)
) %>%
dplyr::filter(is.finite(.data$Public_Sector), is.finite(.data$Private_Sector))
if (nrow(df) == 0L) return(ppt)
# axis limits for nice 45° reference
lim_min <- min(c(df$Private_Sector, df$Public_Sector), na.rm = TRUE)
lim_max <- max(c(df$Private_Sector, df$Public_Sector), na.rm = TRUE)
# build plot (no color scale since we don't map color)
plt <- ggplot2::ggplot(df, ggplot2::aes(x = .data$Private_Sector, y = .data$Public_Sector)) +
ggplot2::geom_point(size = 3) +
ggplot2::geom_text(ggplot2::aes(label = .data$country_name), vjust = -0.6, size = 3) +
ggplot2::geom_abline(slope = 1, intercept = 0, linetype = "dotted") +
ggplot2::geom_smooth(method = "lm", se = FALSE, linetype = "dashed", linewidth = 0.8) +
ggplot2::coord_equal(xlim = c(lim_min, lim_max), ylim = c(lim_min, lim_max), expand = TRUE) +
ggplot2::labs(
title = "Pay Compression: Public vs. Private Sector",
x = "Private Sector Pay Compression (P90/P10)",
y = "Public Sector Pay Compression (P90/P10)"
) +
ggplot2::theme_minimal()
# save image safely
img_path <- tempfile(fileext = ".png")
ok <- TRUE
tryCatch(ggplot2::ggsave(filename = img_path, plot = plt, width = 6, height = 6, dpi = 300),
error = function(e) ok <<- FALSE)
if (!ok || !file.exists(img_path)) return(ppt)
# add slide with image
ppt %>%
officer::add_slide(layout = "Title and Content", master = "Office Theme") %>%
officer::ph_with(
officer::external_img(img_path, height = 4, width = 4),
location = officer::ph_location_type(type = "body")
)
}
generate_conclusion_section <- function(doc) {
# Add Section Title
doc <- doc %>% body_add_par("Conclusion", style = "heading 1")
# Add Conclusion Text
doc <- doc %>% body_add_par(
"This report provides a comprehensive analysis of wage bill trends, gender employment representation, and workforce participation in the public sector.
The findings highlight key trends and disparities across different sectors and countries.",
style = "Normal"
)
return(doc)
}
#Download CVS
output$dl_csv_pay_compression <- downloadHandler(
filename = function() paste0("pay_compression_public_vs_private_", Sys.Date(), ".csv"),
content  = function(file) {
# empty schema so you never get a structurally blank file
empty_schema <- tibble::tibble(
country_name    = character(),
year            = integer(),
private_sector  = numeric(),
public_sector   = numeric()
)
# need selected countries
if (is.null(input$countries_first) || !length(input$countries_first)) {
utils::write.csv(empty_schema, file, row.names = FALSE, na = "", fileEncoding = "UTF-8")
return()
}
# filter source used by the plot
d <- pay_compression_wide %>%
dplyr::filter(country_name %in% input$countries_first)
# ensure required columns exist
if (!all(c("Public_Sector", "Private_Sector") %in% names(d))) {
utils::write.csv(empty_schema, file, row.names = FALSE, na = "", fileEncoding = "UTF-8")
return()
}
# include year if present; otherwise fill NA
out <- d %>%
dplyr::transmute(
country_name,
year           = if ("year" %in% names(d)) as.integer(.data[["year"]]) else NA_integer_,
private_sector = as.numeric(Private_Sector),
public_sector  = as.numeric(Public_Sector)
) %>%
dplyr::arrange(country_name)
if (nrow(out) == 0) out <- empty_schema
utils::write.csv(out, file, row.names = FALSE, na = "", fileEncoding = "UTF-8")
}
)
add_section_slide <- function(ppt, title) {
ppt %>%
add_slide(layout = "Title Slide", master = "Office Theme") %>%
ph_with(
value = fpar(
ftext(title, prop = fp_text(color = "#003366", font.size = 40, bold = TRUE))
),
location = ph_location_type(type = "ctrTitle")
)
}
#Download selected graphs
output$downloadSelectedGraphsDoc <- downloadHandler(
filename = function() {
paste0("Wage_bill_and_public_employment_analysis_Selected_Report_", Sys.Date(), ".docx")
},
content = function(file) {
# Get the selected countries dynamically
selected_countries <- input$download_report_countries
# Initialize Word document
doc <- read_docx()
# Add Report Title
title_style <- fp_text(color = "#722F37", font.size = 20, bold = TRUE)
doc <- doc %>% body_add_fpar(fpar(ftext("Wage bill and public employment analysis", prop = title_style)))
doc <- generate_intro_section(doc, selected_countries)  # Add the Intro First
# Define Section Style
section_style <- fp_text(color = "#003366", font.size = 14, bold = TRUE)
# ✅ Dynamically include only selected sections
selected_sections <- input$selected_graphs
# ✅ Ensure selected_sections is not NULL before checking length
if (is.null(selected_sections) || length(selected_sections) == 0) {
doc <- doc %>% body_add_par("No sections selected for download.", style = "Normal")
} else {
if ("wagebill" %in% selected_sections) {
doc <- generate_wage_bill_analysis_section(doc, selected_countries)
}
if ("wagebill_gdp" %in% selected_sections) {
doc <- generate_gdp_analysis_section(doc, selected_countries)
}
if ("tertiaryeducation" %in% selected_sections) {
doc <- generate_tertiary_education_section(doc, selected_countries)
}
if ("genderwagepremium" %in% selected_sections) {
doc <- generate_wage_premium_gender_section(doc, selected_countries)
}
if ("wagepremiumeducation" %in% selected_sections) {
doc <- generate_wage_premium_education_section(doc, selected_countries)
}
if ("public_employment" %in% selected_sections) {
doc <- generate_public_sector_employment_section(doc, selected_countries)
}
if ("public_workforce" %in% selected_sections) {
doc <- generate_public_sector_workforce_section(doc, selected_countries)
}
if ("gender_workforce" %in% selected_sections) {
doc <- generate_gender_workforce_section(doc, selected_countries)
}
if ("female_leadership" %in% selected_sections) {  # Fixed typo from "femaleocuupation"
doc <- generate_females_occupation_groups_section(doc, selected_countries)
}
if ("wagepremium" %in% selected_sections) {
doc <- generate_wage_premium_report_section(doc, selected_countries)
}
if ("gender_wage_premium" %in% selected_sections) {
doc <- generate_gender_wage_premiumbysector_section(doc, selected_countries)
}
if ("pay_compression" %in% selected_sections) {
doc <- generate_pay_compression_section(doc, selected_countries = selected_countries)
}
}
# ✅ Save the customized report
print(doc, target = file)
}
)
#Download one single report
output$downloadAllGraphsDoc <- downloadHandler(
filename = function() paste0("Wage_bill_and_public_employment_analysis_", Sys.Date(), ".docx"),
content = function(file) {
# 1) sanitize the input up front (prevents if(NA) down the line)
selected_countries <- sanitize_vec(input$download_report_countries)
# 2) init + styles
doc <- officer::read_docx()
title_style   <- officer::fp_text(color = "#722F37", font.size = 20, bold = TRUE)
section_style <- officer::fp_text(color = "#003366", font.size = 14, bold = TRUE)
# 3) safe runner that never crashes the download
run_section <- function(label, fn) {
cat("[download-all] start:", label, "\n")
res <- try(fn(), silent = TRUE)
if (inherits(res, "try-error")) {
msg <- paste0("Skipping '", label, "': ", conditionMessage(attr(res, "condition")))
cat("[download-all] ERROR:", msg, "\n")
# write the message so the doc still builds
assign("doc", officer::body_add_par(doc, msg, style = "Normal"), inherits = TRUE)
} else if (inherits(res, "rdocx")) {
assign("doc", res, inherits = TRUE)
cat("[download-all] done:", label, "\n")
} else {
cat("[download-all] done (no doc returned):", label, "\n")
}
invisible(NULL)
}
# 4) Title + Intro  (pipe passes doc as first arg; we pass countries by name)
doc <- doc %>%
officer::body_add_fpar(officer::fpar(officer::ftext("", prop = title_style)))
run_section("Intro", function() generate_intro_section(doc, selected_countries = selected_countries))
# Section 1
doc <- doc %>%
officer::body_add_fpar(officer::fpar(officer::ftext("Macro-Fundamentals of the Public Sector", prop = section_style)))
run_section("Wage Bill", function() generate_wage_bill_analysis_section(doc, selected_countries = selected_countries))
run_section("% of GDP",  function() generate_gdp_analysis_section(doc, selected_countries = selected_countries))
# Section 2
doc <- doc %>%
officer::body_add_fpar(officer::fpar(officer::ftext("Size and Characteristics of the Public Sector", prop = section_style)))
run_section("Public Employment",  function() generate_public_sector_employment_section(doc, selected_countries = selected_countries))
run_section("Tertiary Education", function() generate_tertiary_education_section(doc, selected_countries = selected_countries))
# Section 3
doc <- doc %>%
officer::body_add_fpar(officer::fpar(officer::ftext("Competitiveness of Public Sector Wages", prop = section_style))) %>%
officer::body_add_par(
"Public sector compensation should theoretically be designed with an awareness of its influence on the broader labor market...",
style = "Normal"
)
run_section("Wage Premium",             function() generate_wage_premium_report_section(doc, selected_countries = selected_countries))
run_section("Wage Premium by Education",function() generate_wage_premium_education_section(doc, selected_countries = selected_countries))
run_section("Pay Compression",          function() generate_pay_compression_section(doc, selected_countries = selected_countries))
# Section 4
doc <- doc %>%
officer::body_add_fpar(officer::fpar(officer::ftext("Equity in the Public Sector", prop = section_style)))
run_section("Gender Workforce",         function() generate_gender_workforce_section(doc, selected_countries = selected_countries))
run_section("Female Leadership",        function() generate_females_occupation_groups_section(doc, selected_countries = selected_countries))
run_section("Gender WP by Sector",      function() generate_gender_wage_premiumbysector_section(doc, selected_countries = selected_countries))
run_section("WP by Gender (public)",    function() generate_wage_premium_gender_section(doc, selected_countries = selected_countries))
# Conclusion (adjust if your function takes only doc)
run_section("Conclusion",               function() generate_conclusion_section(doc))
print(doc, target = file)
}
)
#Power Point Slides
output$downloadSelectedGraphsPPT <- downloadHandler(
filename = function() {
paste0("Wage_bill_and_public_employment_analysis_Selected_Presentation_", Sys.Date(), ".pptx")
},
content = function(file) {
selected_countries <- input$download_report_countries
selected_sections <- input$selected_graphs
# Initialize PowerPoint
ppt <- read_pptx()
# Add a title slide
ppt <- ppt %>%
add_slide(layout = "Title Slide", master = "Office Theme") %>%
ph_with("Wage bill and public employment analysis", location = ph_location_type(type = "ctrTitle")) %>%
ph_with(paste("Generated on", Sys.Date()), location = ph_location_type(type = "subTitle"))
# Only include selected graphs
if (!is.null(selected_sections) && length(selected_sections) > 0) {
if ("wagebill" %in% selected_sections || "wagebill_gdp" %in% selected_sections) {
ppt <- add_section_slide(ppt, "Macro-Fundamentals of the Public Sector")
}
if ("wagebill" %in% selected_sections) {
ppt <- generate_wage_bill_analysis_slide(ppt, selected_countries)
}
if ("wagebill_gdp" %in% selected_sections) {
ppt <- generate_gdp_analysis_slide(ppt, selected_countries)
}
if ("public_employment" %in% selected_sections || "public_workforce" %in% selected_sections || "tertiaryeducation" %in% selected_sections) {
ppt <- add_section_slide(ppt, "Size and Characteristics of the Public Sector")
}
if ("public_employment" %in% selected_sections) {
ppt <- generate_public_sector_employment_slide(ppt, selected_countries)
}
if ("public_workforce" %in% selected_sections) {
ppt <- generate_public_sector_workforce_slide(ppt, selected_countries)
}
if ("tertiaryeducation" %in% selected_sections) {
ppt <- generate_tertiary_education_slide(ppt, selected_countries)
}
if ("genderwagepremium" %in% selected_sections || "wagepremiumeducation" %in% selected_sections || "pay_compression" %in% selected_sections) {
ppt <- add_section_slide(ppt, "Competiiveness of public sector wages")
}
if ("genderwagepremium" %in% selected_sections) {
ppt <- generate_wage_premium_gender_slide(ppt, selected_countries)
}
if ("wagepremiumeducation" %in% selected_sections) {
ppt <-generate_wage_premium_education_slide(ppt, selected_countries)
}
if ("pay_compression" %in% selected_sections) {
ppt <- generate_pay_compression_slide(ppt, selected_countries)
}
if ("wagepremiumgender" %in% selected_sections || "gender_workforce" %in% selected_sections || "gender_wage_premium" %in% selected_sections
|| "female_leadership" %in% selected_sections) {
ppt <- add_section_slide(ppt, "Equity in public sector")
}
if ("wagepremiumgender" %in% selected_sections) {
ppt <- generate_wage_premium_gender_report_slide(ppt, selected_countries)
}
if ("gender_workforce" %in% selected_sections) {
ppt <- generate_gender_workforce_slide(ppt, selected_countries)
}
if ("gender_wage_premium" %in% selected_sections) {
ppt <- generate_gender_wage_premiumbysector_slide(ppt, selected_countries)
}
if ("female_leadership" %in% selected_sections) {
ppt <- generate_females_occupation_groups_slide(ppt, selected_countries)
}
# add more slide generators here as needed
} else {
# If no selection: optionally include a placeholder slide
ppt <- ppt %>%
add_slide(layout = "Title and Content", master = "Office Theme") %>%
ph_with_text(type = "title", str = "No graphs selected") %>%
ph_with_text(type = "body", str = "Please select at least one graph to download.")
}
# Save the PowerPoint
print(ppt, target = file)
}
)
# ---------------------
# Clean base map with legend
output$worldMap <- renderLeaflet({
leaflet(world_spdf) %>%
addTiles() %>%
setView(lng = 0, lat = 20, zoom = 2) %>%
addLegend(
position = "bottomright",
colors = c("gray", "#6DA96F"),
labels = c("No Data", "Reported"),
title = "Indicator Availability",
opacity = 1
)
})
# Create reactive that flags countries that have ANY data for the selected indicator
filtered_data_for_map <- reactive({
req(input$indicatorSelect)
data_wwbi %>%
filter(indicator_name == input$indicatorSelect) %>%
mutate(
any_data = apply(select(., starts_with("year_")), 1, function(x) any(!is.na(x)))
) %>%
filter(any_data) %>%
transmute(country_name, indicator_name, has_data = 1)  # use 'has_data' instead of value_percentage
})
# Update the map
observe({
req(input$indicatorSelect)
reported_countries <- filtered_data_for_map()
if (nrow(reported_countries) == 0) return()
# Match the country names to the shapefile column
world_data_merged <- world_spdf %>%
left_join(reported_countries, by = c("name_long" = "country_name"))
# Use a factor color palette based on 0 (missing) and 1 (has data)
color_pal <- colorFactor(palette = c("gray", "#6DA96F"), domain = c(0, 1))
leafletProxy("worldMap") %>% clearShapes() %>%
addPolygons(
data = world_data_merged,
fillColor = ~color_pal(ifelse(is.na(has_data), 0, has_data)),
fillOpacity = 0.7,
color = "white",
weight = 1,
highlightOptions = highlightOptions(color = "#FFD700", weight = 2, fillOpacity = 0.9),
label = ~paste0("Country: ", name_long, "-",
ifelse(!is.na(has_data), "Reported", "No Data")),
popup = ~paste(
"Country:", name_long, "-",
"Indicator:", ifelse(!is.na(indicator_name), indicator_name, "None"), "-",
ifelse(!is.na(has_data), "Reported", "No Data Available")
)
)
output$countryCount <- renderText({
paste("Total Countries with Data:", nrow(reported_countries))
})
})
# Change info Box colors to "purple" to match the quartz theme
output$numberIndicatorsBox <- renderInfoBox({
infoBox("Indicators", 302, icon = icon("list"), color = "purple")
})
output$numberCountriesBox <- renderInfoBox({
infoBox("Economies", length(unique(data_wwbi$country_name)), icon = icon("globe"), color = "purple")
})
output$temporalCoverageAnnualBox <- renderInfoBox({
infoBox("Temporal Coverage (Annual)", "2000-2022", icon = icon("calendar"), color = "purple")
})
output$temporalCoverageYearsBox <- renderInfoBox({
infoBox("Temporal Coverage (Years)", "22", icon = icon("calendar"), color = "purple")
})
output$lastUpdatedBox <- renderInfoBox({
infoBox("Last Updated", "2025", icon = icon("clock"), color = "purple")
})
}
shinyApp(ui = ui, server = server)
